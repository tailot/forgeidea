/**
 * @fileoverview This file provides cryptographic utilities for encryption and decryption
 * using the AES-256-GCM algorithm. It defines the `FlowCryptographer` class
 * which encapsulates the encryption and decryption logic, and the `EncryptedPayload`
 * interface for structuring encrypted messages.
 */
import * as crypto from 'crypto';

/**
 * The cryptographic algorithm used for encryption and decryption.
 * Specifies AES-256-GCM.
 * @type {crypto.CipherGCMTypes}
 */
const ALGORITHM = 'aes-256-gcm' as crypto.CipherGCMTypes;

/**
 * The length of the Initialization Vector (IV) in bytes.
 * For GCM, a 12-byte IV is commonly recommended.
 * @type {number}
 */
const IV_LENGTH = 12;

/**
 * Interface defining the structure of an encrypted payload.
 * This structure includes the initialization vector (IV), the encrypted data,
 * and an authentication tag to ensure data integrity and authenticity.
 */
export interface EncryptedPayload {
  /**
   * The initialization vector (IV) used for encryption, encoded as a hex string.
   * The IV must be unique for each encryption operation with the same key.
   */
  iv: string;
  /**
   * The encrypted data (ciphertext), encoded as a hex string.
   */
  encryptedData: string;
  /**
   * The authentication tag generated by the GCM mode, encoded as a hex string.
   * This tag is used to verify the integrity and authenticity of the encrypted data.
   */
  authTag: string;
}

/**
 * Provides methods for encrypting and decrypting strings using AES-256-GCM.
 * This class encapsulates key management (derived from a provided secret key buffer)
 * and the specifics of the GCM authenticated encryption mode.
 */
export class FlowCryptographer {
  private key: Buffer;

  /**
   * Creates an instance of FlowCryptographer.
   * The constructor expects a secret key as a Buffer.
   *
   * @param {Buffer} secretKeyBuffer - The secret key for AES-256, must be 32 bytes in length.
   * @throws {Error} If the secretKeyBuffer is not 32 bytes long.
   */
  constructor(secretKeyBuffer: Buffer) {
    if (secretKeyBuffer.length !== 32) {
      throw new Error('Secret key must be 32 bytes for AES-256.');
    }
    this.key = secretKeyBuffer;
  }

  /**
   * Encrypts a plaintext string using AES-256-GCM.
   *
   * The process involves:
   * 1. Generating a random Initialization Vector (IV).
   * 2. Creating an AES-256-GCM cipher instance with the key and IV.
   * 3. Encrypting the plaintext (UTF-8) into hex format.
   * 4. Retrieving the authentication tag from the cipher.
   * 5. Returning an `EncryptedPayload` object containing the hex-encoded IV,
   *    encrypted data, and authentication tag.
   *
   * @param {string} plaintext - The string to encrypt.
   * @returns {EncryptedPayload} An object containing the IV, encrypted data, and auth tag, all as hex strings.
   * @throws {Error} If encryption fails at any step.
   */
  encrypt(plaintext: string): EncryptedPayload {
    try {
      const iv: Buffer = crypto.randomBytes(IV_LENGTH);
      const cipher: crypto.CipherGCM = crypto.createCipheriv(ALGORITHM, this.key, iv);

      let encrypted: string = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      const authTag: Buffer = cipher.getAuthTag();

      return {
        iv: iv.toString('hex'),
        encryptedData: encrypted,
        authTag: authTag.toString('hex'),
      };
    } catch (error) {
      console.error('FlowCryptographer - Error during encryption:', error);
      throw new Error(`Encryption failed: ${(error as Error).message}`);
    }
  }

  /**
   * Decrypts an `EncryptedPayload` object (containing IV, encrypted data, and auth tag)
   * back to a plaintext string using AES-256-GCM.
   *
   * The process involves:
   * 1. Converting the hex-encoded IV, encrypted data, and auth tag from the payload into Buffers.
   * 2. Creating an AES-256-GCM decipher instance with the key and IV.
   * 3. Setting the authentication tag on the decipher. This is crucial for GCM to verify integrity.
   * 4. Decrypting the data from hex format back to UTF-8 plaintext.
   * 5. Returning the decrypted string.
   *
   * @param {EncryptedPayload} payload - The encrypted payload object.
   * @returns {string} The decrypted plaintext string.
   * @throws {Error} If decryption fails. This can happen due to various reasons including
   *   incorrect key, tampered data (auth tag mismatch), or a corrupted payload.
   */
  decrypt(payload: EncryptedPayload): string {
    try {
      const iv: Buffer = Buffer.from(payload.iv, 'hex');
      const encryptedData: Buffer = Buffer.from(payload.encryptedData, 'hex');
      const authTag: Buffer = Buffer.from(payload.authTag, 'hex');

      const decipher: crypto.DecipherGCM = crypto.createDecipheriv(ALGORITHM, this.key, iv);
      decipher.setAuthTag(authTag);

      let decrypted: string = decipher.update(encryptedData, undefined, 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;
    } catch (error) {
      console.error('FlowCryptographer - Error during decryption:', error);
      throw new Error(`Decryption failed (possible tampering, wrong key, or corrupted payload): ${(error as Error).message}`);
    }
  }
}

/*
async function testCryptography() {
  const basekey = process.env.KEYCIPHER || crypto.randomBytes(32).toString('base64');
  //OR
  //const basekey = crypto.randomBytes(32);

  const exampleSecretKey =Buffer.from(basekey, 'base64');
  
  const cryptographer = new FlowCryptographer(exampleSecretKey);

  const originalMessage = "This is a test message for the FlowCryptographer library!";
  console.log("Original Message:", originalMessage);

  try {
    // Encryption
    const encryptedPayload = cryptographer.encrypt(originalMessage);
    console.log("\nEncrypted Payload:");
    console.log("IV:", encryptedPayload.iv);
    console.log("Encrypted Data:", encryptedPayload.encryptedData);
    console.log("Auth Tag:", encryptedPayload.authTag);

    // Decryption
    const decryptedMessage = cryptographer.decrypt(encryptedPayload);
    console.log("\nDecrypted Message:", decryptedMessage);

    if (originalMessage === decryptedMessage) {
      console.log("\nSuccess: Encryption and decryption work correctly!");
    } else {
      console.error("\nError: The decrypted message does not match the original.");
    }

// Failure test (e.g., tampered auth tag)
console.log("\n--- Failure Test with Tampered Auth Tag ---");
const tamperedPayload: EncryptedPayload = {
    ...encryptedPayload,
    authTag: crypto.randomBytes(AUTH_TAG_LENGTH).toString('hex')
};
try {
    cryptographer.decrypt(tamperedPayload);
} catch (e) {
    console.log("Decryption failed as expected:", (e as Error).message);
}


  } catch (error) {
    console.error("Error in test:", (error as Error).message);
  }
}

// Run the test if this file is executed directly
if (require.main === module) {
  testCryptography();
}
*/